// Generated by LiveScript 1.4.0
(function(){
  var tempPoint1, tempPoint2, DIRENUM, ORDINALS, Trystal, out$ = typeof exports != 'undefined' && exports || this;
  tempPoint1 = new PIXI.Point(0, 0);
  tempPoint2 = new PIXI.Point(0, 0);
  DIRENUM = {
    left: 0,
    up: 1,
    right: 2,
    down: 3
  };
  ORDINALS = ['nw', 'ne', 'se', 'sw'];
  out$.Trystal = Trystal = (function(){
    Trystal.displayName = 'Trystal';
    var fallId, prototype = Trystal.prototype, constructor = Trystal;
    function Trystal(width, height){
      var container, x$;
      this.width = width;
      this.height = height;
      this.filldist = Math.sqrt(width * width + height * height) / 2;
      this.mindist = Math.min(width, height);
      this.container = container = new PIXI.Graphics();
      x$ = container.position;
      x$.x = width / 2;
      x$.y = height / 2;
      container.addChild(this.bullseye = new PIXI.Graphics());
      this.initBullseye();
      container.addChild(this.mass = new PIXI.Graphics());
      this.initMass();
    }
    prototype.rad = 10;
    prototype.precision = 2;
    prototype.falling = {};
    prototype.unitTrist = function(graphics, cx, cy){
      var rad, pre, centers;
      rad = this.rad;
      pre = this.precision;
      graphics.beginFill(0x700BCC, 1);
      graphics.drawRect(cx - rad, cy - rad, 2 * rad, 2 * rad);
      centers = graphics.centers || (graphics.centers = []);
      centers.push(cx, cy);
      graphics.beginFill(0x70CC0B, 1);
      graphics.beginFill(0xCC700B, 1);
      (graphics.edges0 || (graphics.edges0 = [])).push(cx + 2 * rad, cy);
      (graphics.edges1 || (graphics.edges1 = [])).push(cx, cy + 2 * rad);
      (graphics.edges2 || (graphics.edges2 = [])).push(cx - 2 * rad, cy);
      return (graphics.edges3 || (graphics.edges3 = [])).push(cx, cy - 2 * rad);
    };
    prototype.simplifyEdges = function(graphics){
      var centers, i$, ref$, v, edges, newedges, rad, pre, j$, len$, i, isCenter, k$, len1$, j, results$ = [];
      centers = graphics.centers;
      for (i$ in ref$ = DIRENUM) {
        v = ref$[i$];
        edges = graphics["edges" + v];
        newedges = [];
        rad = this.rad;
        pre = this.precision;
        for (j$ = 0, len$ = edges.length; j$ < len$; j$ += 2) {
          i = j$;
          isCenter = false;
          for (k$ = 0, len1$ = centers.length; k$ < len1$; k$ += 2) {
            j = k$;
            if (edges[i] === centers[j] && edges[i + 1] === centers[j + 1]) {
              isCenter = true;
              break;
            }
          }
          if (!isCenter) {
            newedges.push(edges[i], edges[i + 1]);
          }
        }
        results$.push(graphics["edges" + v] = newedges);
      }
      return results$;
    };
    prototype.initMass = function(){
      var mass, rad;
      mass = this.mass;
      rad = this.rad;
      mass.clear();
      mass.lineStyle(1, 0xAACCBB, 1);
      this.unitTrist(mass, 0, 0);
      return mass;
    };
    prototype.initBullseye = function(){
      var rad, bullseye, alt, i$, step$, to$, dw;
      rad = this.rad;
      bullseye = this.bullseye;
      bullseye.clear();
      alt = true;
      for (i$ = Math.ceil(this.filldist / rad) * rad, to$ = 3 * rad, step$ = -2 * rad; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
        dw = i$;
        bullseye.beginFill((alt = !alt) ? 0x222222 : 0x333333, 1);
        if (this.mindist / 2 - rad <= dw && dw < this.mindist / 2 + rad) {
          bullseye.beginFill(0x552222, 1);
        }
        bullseye.drawPolygon(-dw, -dw, -dw, dw, dw, dw, dw, -dw);
        bullseye.endFill();
      }
      return bullseye;
    };
    fallId = 0;
    prototype.newFalling = function(){
      var obj, rad, m, x$, y$;
      obj = new PIXI.Graphics();
      rad = this.rad;
      this.container.addChild(obj);
      obj.lineStyle(1, 0xAACCBB, 1);
      m = 2 * Math.round(Math.random()) - 1;
      if (Math.random() < 0.5) {
        obj.direction = m < 0 ? "down" : "up";
        x$ = obj.position;
        x$.x = 0;
        x$.y = m * this.mindist / 2;
        obj.velocity = new PIXI.Point(0, -m * 2);
      } else {
        obj.direction = m < 0 ? "right" : "left";
        y$ = obj.position;
        y$.y = 0;
        y$.x = m * this.mindist / 2;
        obj.velocity = new PIXI.Point(-m * 2, 0);
      }
      obj.beginFill(0x700BCC, 1);
      this.unitTrist(obj, 0, 0);
      return this.falling[fallId++] = obj;
    };
    prototype.dropFalling = function(){
      var mass, container, rad, pre, k, ref$, obj, pos, vel, dir, stuck, stuckAt, theta, rot_num, corrected_dir, edges, centers, i$, len$, ei, j$, len1$, ci, ref1$, ref2$, width, height, xDist, yDist, sr, cr, tr, findex, fdir, tx, ty, results$ = [];
      mass = this.mass;
      container = this.container;
      rad = this.rad;
      pre = this.precision;
      for (k in ref$ = this.falling) {
        obj = ref$[k];
        pos = obj.position;
        vel = obj.velocity;
        dir = obj.direction;
        stuck = false;
        stuckAt = 0;
        theta = mass.rotation;
        rot_num = Math.floor(Math.abs(theta) / Math.PI * 2) % 4;
        if (theta < 0) {
          rot_num = 4 - rot_num;
        }
        corrected_dir = (DIRENUM[dir] - rot_num) % 4;
        if (corrected_dir < 0) {
          corrected_dir = 4 + corrected_dir;
        }
        edges = mass["edges" + corrected_dir];
        centers = obj.centers;
        for (i$ = 0, len$ = edges.length; i$ < len$; i$ += 2) {
          ei = i$;
          tempPoint1.x = edges[ei];
          tempPoint1.y = edges[ei + 1];
          mass.updateTransform();
          mass.worldTransform.apply(tempPoint1, tempPoint1);
          obj.updateTransform();
          obj.worldTransform.applyInverse(tempPoint1, tempPoint1);
          for (j$ = 0, len1$ = centers.length; j$ < len1$; j$ += 2) {
            ci = j$;
            if (Math.abs(tempPoint1.x - centers[ci]) < rad / pre && Math.abs(tempPoint1.y - centers[ci + 1]) < rad / pre) {
              stuck = true;
              stuckAt = ei;
              break;
            }
          }
          if (stuck) {
            break;
          }
        }
        if (stuck) {
          container.removeChild(obj);
          this.unitTrist(mass, edges[ei], edges[ei + 1]);
          if (Math.max(Math.abs(edges[ei]), Math.abs(edges[ei + 1])) >= this.mindist / 2 - 2 * rad) {
            throw "You lost!! Ha!";
          }
          this.simplifyEdges(mass);
          results$.push((ref2$ = (ref1$ = this.falling)[k], delete ref1$[k], ref2$));
        } else {
          container.updateTransform();
          container.worldTransform.apply(pos, tempPoint1);
          width = this.width;
          height = this.height;
          xDist = width / 2 + 2 * rad;
          yDist = height / 2 + 2 * rad;
          theta = container.rotation;
          sr = container._sr;
          cr = container._cr;
          tr = sr / cr;
          rot_num = Math.floor(Math.abs(theta) / Math.PI * 2) % 4;
          if (theta < 0) {
            rot_num = 4 - rot_num;
          }
          findex = DIRENUM[dir];
          fdir = ORDINALS[(findex + rot_num) % 4];
          if (rot_num % 2 !== 0) {
            tx = pos.x;
            ty = pos.y;
            pos.x = ty;
            pos.y = tx;
          }
          switch (fdir) {
          case 'nw':
            if (tempPoint1.y < -2 * rad || tempPoint1.x < -2 * rad) {
              pos.x = Math.min(yDist / sr - pos.y / tr, xDist / cr + pos.y * tr);
            }
            break;
          case 'se':
            if (tempPoint1.y > height + 2 * rad || tempPoint1.x > width + 2 * rad) {
              pos.x = -Math.min(yDist / sr + pos.y / tr, xDist / cr - pos.y * tr);
            }
            break;
          case 'ne':
            if (tempPoint1.y < -2 * rad || tempPoint1.x > width + 2 * rad) {
              pos.y = Math.min(yDist / cr - pos.x * tr, xDist / sr + pos.x / tr);
            }
            break;
          case 'sw':
            if (tempPoint1.y > height + 2 * rad || tempPoint1.x < -2 * rad) {
              pos.y = -Math.min(yDist / cr + pos.x * tr, xDist / sr - pos.x / tr);
            }
          }
          if (rot_num % 2 !== 0) {
            tx = pos.x;
            ty = pos.y;
            pos.x = ty;
            pos.y = tx;
          }
          pos.x += vel.x;
          results$.push(pos.y += vel.y);
        }
      }
      return results$;
    };
    prototype.shiftFalling = function(spin){
      var rad, i$, ref$, obj, dir, pos, tx, ty, results$ = [];
      rad = this.rad;
      for (i$ in ref$ = this.falling) {
        obj = ref$[i$];
        dir = obj.direction;
        pos = obj.position;
        tx = pos.x;
        ty = pos.y;
        switch (dir) {
        case 'left':
          ty += 2 * rad * spin;
          results$.push(pos.y = Math.abs(ty) >= this.mindist / 2 ? -pos.y : ty);
          break;
        case 'right':
          ty -= 2 * rad * spin;
          results$.push(pos.y = Math.abs(ty) >= this.mindist / 2 ? -pos.y : ty);
          break;
        case 'up':
          tx -= 2 * rad * spin;
          results$.push(pos.x = Math.abs(tx) >= this.mindist / 2 ? -pos.x : tx);
          break;
        case 'down':
          tx += 2 * rad * spin;
          results$.push(pos.x = Math.abs(tx) >= this.mindist / 2 ? -pos.x : tx);
        }
      }
      return results$;
    };
    prototype.rotate = function(spin){
      var i$, ref$, obj, results$ = [];
      this.mass.rotation += spin * Math.PI / 2;
      for (i$ in ref$ = this.falling) {
        obj = ref$[i$];
        results$.push(obj.rotation += spin * Math.PI / 2);
      }
      return results$;
    };
    return Trystal;
  }());
}).call(this);

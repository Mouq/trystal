// Generated by LiveScript 1.4.0
(function(){
  var width, height, filldist, renderer, stage, x$, y$, mass, z$, bullseye, tempPoint, square, animate;
  width = 400;
  height = 400;
  filldist = Math.sqrt(width * width + height * height) / 2;
  renderer = new PIXI.autoDetectRenderer(width, height, {
    antialias: true
  });
  stage = new PIXI.Container();
  x$ = stage.pivot;
  x$.x = width / 2;
  x$.y = height / 2;
  y$ = stage.position;
  y$.x = width / 2;
  y$.y = height / 2;
  mass = new PIXI.Graphics();
  stage.addChild(mass);
  z$ = mass.position;
  z$.x = width / 2;
  z$.y = height / 2;
  bullseye = new PIXI.Graphics();
  stage.addChild(bullseye);
  bullseye.position = mass.position;
  tempPoint = new PIXI.Point(0, 0);
  square = [-1, -1, -1, 1, 1, 1, 1, -1];
  window.Tristal = {
    rad: 20,
    precision: 10,
    mass: mass,
    bullseye: bullseye,
    collidePoints: [],
    drawMass: function(){
      var mass, rad, i$, ref$, len$, p;
      mass = this.mass;
      rad = this.rad;
      mass.clear();
      mass.lineStyle(2, 0xAACCBB, 1);
      mass.beginFill(0x700BCC, 1);
      mass.drawPolygon(-rad, -rad, -rad, rad, rad, rad, rad, -rad);
      this.collidePoints = [new PIXI.Point(0, 2 * rad), new PIXI.Point(2 * rad, 0), new PIXI.Point(0, -2 * rad), new PIXI.Point(-2 * rad, 0)];
      for (i$ = 0, len$ = (ref$ = this.collidePoints).length; i$ < len$; ++i$) {
        p = ref$[i$];
        mass.drawCircle(p.x, p.y, rad / 10);
      }
      return mass;
    },
    drawBullseye: function(){
      var bullseye, rad, i$, step$, to$, dw;
      bullseye = this.bullseye;
      rad = this.rad;
      bullseye.clear();
      bullseye.lineStyle(2, 0xAACCBB, 1);
      for (i$ = 3 * rad, to$ = filldist, step$ = 2 * rad; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
        dw = i$;
        bullseye.drawPolygon(-dw, -dw, -dw, dw, dw, dw, dw, -dw);
      }
      return mass;
    },
    falling: [],
    newFalling: function(){
      var obj, rad, x$, precision, x;
      obj = new PIXI.Graphics();
      rad = this.rad;
      stage.addChild(obj);
      obj.lineStyle(2, 0xAACCBB, 1);
      x$ = obj.position;
      x$.x = width / 2;
      x$.y = -rad;
      obj.velocity = new PIXI.Point(0, 2);
      obj.beginFill(0x700BCC, 1);
      obj.drawPolygon([-rad, -rad, -rad, rad, rad, rad, rad, -rad]);
      precision = this.precision;
      obj.drawPolygon((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = square).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(x * rad / precision);
        }
        return results$;
      }()));
      obj.endFill();
      return obj;
    },
    dropFalling: function(){
      var mass, rad, i$, ref$, len$, i, obj, pos, vel, col, j$, ref1$, len1$, p, results$ = [];
      mass = this.mass;
      rad = this.rad;
      for (i$ = 0, len$ = (ref$ = this.falling).length; i$ < len$; ++i$) {
        i = i$;
        obj = ref$[i$];
        pos = obj.position;
        vel = obj.velocity;
        col = false;
        for (j$ = 0, len1$ = (ref1$ = this.collidePoints).length; j$ < len1$; ++j$) {
          p = ref1$[j$];
          mass.worldTransform.apply(p, tempPoint);
          obj.worldTransform.applyInverse(tempPoint, tempPoint);
          if (obj.graphicsData[1].shape.contains(tempPoint.x, tempPoint.y)) {
            col = true;
            break;
          }
        }
        if (col) {
          stage.removeChild(obj);
          pos.x -= width / 2;
          pos.y -= height / 2;
          results$.push(this.falling[i] = this.newFalling());
        } else {
          pos.x = (pos.x + vel.x + rad) % (filldist * 2 + 2 * rad) - rad;
          results$.push(pos.y = (pos.y + vel.y + rad) % (filldist * 2 + 2 * rad) - rad);
        }
      }
      return results$;
    },
    drawFalling: function(){
      var i$, ref$, len$, obj, shape, results$ = [];
      for (i$ = 0, len$ = (ref$ = this.falling).length; i$ < len$; ++i$) {
        obj = ref$[i$];
        shape = obj.myshape;
        results$.push(obj.drawShape(shape));
      }
      return results$;
    }
  };
  Tristal.drawMass();
  Tristal.drawBullseye();
  Tristal.falling.push(Tristal.newFalling());
  animate = function(timestamp){
    Tristal.dropFalling();
    renderer.render(stage);
    return requestAnimationFrame(animate);
  };
  animate();
  document.body.appendChild(renderer.view);
}).call(this);

// Generated by LiveScript 1.4.0
(function(){
  var width, height, filldist, renderer, stage, x$, y$, mass, z$, bullseye, tempPoint1, tempPoint2, square, animate;
  width = 600;
  height = 400;
  filldist = Math.sqrt(width * width + height * height) / 2;
  renderer = new PIXI.autoDetectRenderer(width, height, {
    antialias: true
  });
  stage = new PIXI.Container();
  x$ = stage.pivot;
  x$.x = width / 2;
  x$.y = height / 2;
  y$ = stage.position;
  y$.x = width / 2;
  y$.y = height / 2;
  mass = new PIXI.Graphics();
  z$ = mass.position;
  z$.x = width / 2;
  z$.y = height / 2;
  bullseye = new PIXI.Graphics();
  bullseye.position = mass.position;
  stage.addChild(bullseye);
  stage.addChild(mass);
  tempPoint1 = new PIXI.Point(0, 0);
  tempPoint2 = new PIXI.Point(0, 0);
  square = [-1, -1, -1, 1, 1, 1, 1, -1];
  window.Tristal = {
    rad: 20,
    precision: 5,
    mass: mass,
    unitTrist: function(graphics, cx, cy){
      var rad, pre, centers, gedges, newedges, i$, len$, i, results$ = [];
      rad = this.rad;
      pre = this.precision;
      mass.beginFill(0x700BCC, 1);
      graphics.drawRect(cx - rad, cy - rad, 2 * rad, 2 * rad);
      centers = graphics.centers || (graphics.centers = []);
      centers.push(cx, cy);
      graphics.beginFill(0x70CC0B, 1);
      graphics.drawCircle(cx, cy, rad / pre);
      graphics.beginFill(0xCC700B, 1);
      gedges = graphics.edges || (graphics.edges = []);
      newedges = [cx + 2 * rad, cy, cx - 2 * rad, cy, cx, cy + 2 * rad, cx, cy - 2 * rad];
      for (i$ = 0, len$ = newedges.length; i$ < len$; i$ += 2) {
        i = i$;
        graphics.drawCircle(newedges[i], newedges[i + 1], rad / pre);
        results$.push(gedges.push(newedges[i], newedges[i + 1]));
      }
      return results$;
    },
    simplifyEdges: function(graphics){
      var centers, edges, newedges, rad, pre, i$, len$, i, isCenter, j$, len1$, j;
      centers = graphics.centers;
      edges = graphics.edges;
      newedges = [];
      rad = this.rad;
      pre = this.precision;
      for (i$ = 0, len$ = edges.length; i$ < len$; i$ += 2) {
        i = i$;
        isCenter = false;
        for (j$ = 0, len1$ = centers.length; j$ < len1$; j$ += 2) {
          j = j$;
          if (edges[i] === centers[j] && edges[i + 1] === centers[j + 1]) {
            isCenter = true;
            break;
          }
        }
        if (!isCenter) {
          newedges.push(edges[i], edges[i + 1]);
        }
      }
      return graphics.edges = newedges;
    },
    initMass: function(){
      var mass, rad;
      mass = this.mass;
      rad = this.rad;
      mass.clear();
      mass.lineStyle(1, 0xAACCBB, 1);
      this.unitTrist(mass, 0, 0);
      return mass;
    },
    initBullseye: function(){
      var rad, alt, i$, step$, to$, dw;
      rad = this.rad;
      bullseye.clear();
      alt = true;
      for (i$ = filldist, to$ = 3 * rad, step$ = -2 * rad; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
        dw = i$;
        bullseye.beginFill((alt = !alt) ? 0x222222 : 0x333333, 1);
        bullseye.drawPolygon(-dw, -dw, -dw, dw, dw, dw, dw, -dw);
        bullseye.endFill();
      }
      return mass;
    },
    falling: [],
    newFalling: function(){
      var obj, rad, x$;
      obj = new PIXI.Graphics();
      rad = this.rad;
      stage.addChild(obj);
      obj.lineStyle(1, 0xAACCBB, 1);
      x$ = obj.position;
      x$.x = width / 2;
      x$.y = -rad;
      obj.velocity = new PIXI.Point(0, 2);
      obj.beginFill(0x700BCC, 1);
      this.unitTrist(obj, 0, 0);
      return obj;
    },
    dropFalling: function(){
      var mass, rad, pre, i$, ref$, len$, i, obj, pos, vel, stuck, stuckAt, edges, centers, j$, len1$, ei, k$, len2$, ci, results$ = [];
      mass = this.mass;
      rad = this.rad;
      pre = this.precision;
      for (i$ = 0, len$ = (ref$ = this.falling).length; i$ < len$; ++i$) {
        i = i$;
        obj = ref$[i$];
        pos = obj.position;
        vel = obj.velocity;
        stuck = false;
        stuckAt = 0;
        edges = mass.edges;
        centers = obj.centers;
        for (j$ = 0, len1$ = edges.length; j$ < len1$; j$ += 2) {
          ei = j$;
          tempPoint1.x = edges[ei];
          tempPoint1.y = edges[ei + 1];
          mass.updateTransform();
          mass.worldTransform.apply(tempPoint1, tempPoint1);
          obj.updateTransform();
          obj.worldTransform.applyInverse(tempPoint1, tempPoint2);
          for (k$ = 0, len2$ = centers.length; k$ < len2$; k$ += 2) {
            ci = k$;
            if (Math.abs(tempPoint2.x - centers[ci]) < rad / pre && Math.abs(tempPoint2.y - centers[ci + 1]) < rad / pre) {
              stuck = true;
              stuckAt = ei;
              break;
            }
          }
          if (stuck) {
            break;
          }
        }
        if (stuck) {
          if (Math.abs(edges[ei]) >= width / 2 - rad || Math.abs(edges[ei + 1]) >= height / 2 - rad) {
            throw "You lost!! Ha!";
          }
          stage.removeChild(obj);
          this.unitTrist(mass, edges[ei], edges[ei + 1]);
          this.simplifyEdges(mass);
          results$.push(this.falling[i] = this.newFalling());
        } else {
          pos.x = (pos.x + vel.x + rad) % (filldist * 2 + 2 * rad) - rad;
          results$.push(pos.y = (pos.y + vel.y + rad) % (filldist * 2 + 2 * rad) - rad);
        }
      }
      return results$;
    },
    drawFalling: function(){
      var i$, ref$, len$, obj, shape, results$ = [];
      for (i$ = 0, len$ = (ref$ = this.falling).length; i$ < len$; ++i$) {
        obj = ref$[i$];
        shape = obj.myshape;
        results$.push(obj.drawShape(shape));
      }
      return results$;
    }
  };
  Tristal.initBullseye();
  Tristal.initMass();
  Tristal.falling.push(Tristal.newFalling());
  animate = function(timestamp){
    stage.rotation += 0.001;
    Tristal.dropFalling();
    renderer.render(stage);
    return requestAnimationFrame(animate);
  };
  animate();
  document.body.appendChild(renderer.view);
}).call(this);

// Generated by LiveScript 1.4.0
(function(){
  var width, height, filldist, mindist, renderer, stage, tristalbox, x$, mass, bullseye, tempPoint1, tempPoint2, square, DIRENUM, ORDINALS, fallId, animate;
  width = 1000;
  height = 600;
  filldist = Math.sqrt(width * width + height * height) / 2;
  mindist = Math.min(width, height);
  renderer = new PIXI.autoDetectRenderer(width, height, {
    antialias: true
  });
  stage = new PIXI.Container();
  tristalbox = new PIXI.Graphics();
  stage.addChild(tristalbox);
  x$ = tristalbox.position;
  x$.x = width / 2;
  x$.y = height / 2;
  mass = new PIXI.Graphics();
  bullseye = new PIXI.Graphics();
  bullseye.position = mass.position;
  tristalbox.addChild(bullseye);
  tristalbox.addChild(mass);
  tempPoint1 = new PIXI.Point(0, 0);
  tempPoint2 = new PIXI.Point(0, 0);
  square = [-1, -1, -1, 1, 1, 1, 1, -1];
  DIRENUM = {
    left: 0,
    up: 1,
    right: 2,
    down: 3
  };
  ORDINALS = ['nw', 'ne', 'se', 'sw'];
  window.Tristal = {
    rad: 10,
    precision: 5,
    mass: mass,
    falling: {},
    unitTrist: function(graphics, cx, cy){
      var rad, pre, centers;
      rad = this.rad;
      pre = this.precision;
      mass.beginFill(0x700BCC, 1);
      graphics.drawRect(cx - rad, cy - rad, 2 * rad, 2 * rad);
      centers = graphics.centers || (graphics.centers = []);
      centers.push(cx, cy);
      graphics.beginFill(0x70CC0B, 1);
      graphics.beginFill(0xCC700B, 1);
      (graphics.leftEdges || (graphics.leftEdges = [])).push(cx + 2 * rad, cy);
      (graphics.rightEdges || (graphics.rightEdges = [])).push(cx - 2 * rad, cy);
      (graphics.upEdges || (graphics.upEdges = [])).push(cx, cy + 2 * rad);
      return (graphics.downEdges || (graphics.downEdges = [])).push(cx, cy - 2 * rad);
    },
    simplifyEdges: function(graphics){
      var centers, i$, ref$, len$, dir, edges, newedges, rad, pre, j$, len1$, i, isCenter, k$, len2$, j, results$ = [];
      centers = graphics.centers;
      for (i$ = 0, len$ = (ref$ = ["right", "left", "up", "down"]).length; i$ < len$; ++i$) {
        dir = ref$[i$];
        edges = graphics[dir + "Edges"];
        newedges = [];
        rad = this.rad;
        pre = this.precision;
        for (j$ = 0, len1$ = edges.length; j$ < len1$; j$ += 2) {
          i = j$;
          isCenter = false;
          for (k$ = 0, len2$ = centers.length; k$ < len2$; k$ += 2) {
            j = k$;
            if (edges[i] === centers[j] && edges[i + 1] === centers[j + 1]) {
              isCenter = true;
              break;
            }
          }
          if (!isCenter) {
            newedges.push(edges[i], edges[i + 1]);
          }
        }
        results$.push(graphics[dir + "Edges"] = newedges);
      }
      return results$;
    },
    initMass: function(){
      var mass, rad;
      mass = this.mass;
      rad = this.rad;
      mass.clear();
      mass.lineStyle(1, 0xAACCBB, 1);
      this.unitTrist(mass, 0, 0);
      return mass;
    },
    initBullseye: function(){
      var rad, alt, i$, step$, to$, dw;
      rad = this.rad;
      bullseye.clear();
      alt = true;
      for (i$ = Math.ceil(filldist / rad) * rad, to$ = 3 * rad, step$ = -2 * rad; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
        dw = i$;
        bullseye.beginFill((alt = !alt) ? 0x222222 : 0x333333, 1);
        if (mindist / 2 - rad <= dw && dw < mindist / 2 + rad) {
          bullseye.beginFill(0x552222, 1);
        }
        bullseye.drawPolygon(-dw, -dw, -dw, dw, dw, dw, dw, -dw);
        bullseye.endFill();
      }
      return mass;
    },
    newFalling: function(){
      var obj, mass, rad, m, x$, y$, ref$, ref1$;
      obj = new PIXI.Graphics();
      mass = new PIXI.Graphics();
      rad = this.rad;
      tristalbox.addChild(obj);
      obj.lineStyle(1, 0xAACCBB, 1);
      m = 2 * Math.round(Math.random()) - 1;
      if (Math.random() < 0.5) {
        obj.direction = m < 0 ? "down" : "up";
        x$ = obj.position;
        x$.x = 0;
        x$.y = m * mindist / 2;
        obj.velocity = new PIXI.Point(0, -m * 2);
      } else {
        obj.direction = m < 0 ? "right" : "left";
        y$ = obj.position;
        y$.y = 0;
        y$.x = m * mindist / 2;
        obj.velocity = new PIXI.Point(-m * 2, 0);
      }
      ref1$ = mass.position, (ref$ = obj.position).x += ref1$.x, ref$.y += ref1$.y;
      obj.beginFill(0x700BCC, 1);
      this.unitTrist(obj, 0, 0);
      return obj;
    },
    dropFalling: function(){
      var mass, rad, pre, k, ref$, obj, pos, vel, dir, stuck, stuckAt, edges, centers, i$, len$, ei, j$, len1$, ci, ref1$, ref2$, xDist, yDist, theta, sr, cr, tr, rot_num, findex, fdir, tx, ty, results$ = [];
      mass = this.mass;
      rad = this.rad;
      pre = this.precision;
      for (k in ref$ = this.falling) {
        obj = ref$[k];
        pos = obj.position;
        vel = obj.velocity;
        dir = obj.direction;
        stuck = false;
        stuckAt = 0;
        edges = mass[dir + "Edges"];
        centers = obj.centers;
        for (i$ = 0, len$ = edges.length; i$ < len$; i$ += 2) {
          ei = i$;
          tempPoint1.x = edges[ei];
          tempPoint1.y = edges[ei + 1];
          mass.updateTransform();
          mass.worldTransform.apply(tempPoint1, tempPoint1);
          obj.updateTransform();
          obj.worldTransform.applyInverse(tempPoint1, tempPoint1);
          for (j$ = 0, len1$ = centers.length; j$ < len1$; j$ += 2) {
            ci = j$;
            if (Math.abs(tempPoint1.x - centers[ci]) < rad / pre && Math.abs(tempPoint1.y - centers[ci + 1]) < rad / pre) {
              stuck = true;
              stuckAt = ei;
              break;
            }
          }
          if (stuck) {
            break;
          }
        }
        if (stuck) {
          tristalbox.removeChild(obj);
          this.unitTrist(mass, edges[ei], edges[ei + 1]);
          if (Math.max(Math.abs(edges[ei]), Math.abs(edges[ei + 1])) >= mindist / 2 - 2 * rad) {
            throw "You lost!! Ha!";
          }
          this.simplifyEdges(mass);
          results$.push((ref2$ = (ref1$ = this.falling)[k], delete ref1$[k], ref2$));
        } else {
          tristalbox.updateTransform();
          tristalbox.worldTransform.apply(pos, tempPoint1);
          xDist = width / 2 + 2 * rad;
          yDist = height / 2 + 2 * rad;
          theta = tristalbox.rotation;
          sr = tristalbox._sr;
          cr = tristalbox._cr;
          tr = sr / cr;
          rot_num = Math.floor(Math.abs(theta) / Math.PI * 2) % 4;
          if (theta < 0) {
            rot_num = 4 - rot_num;
          }
          findex = DIRENUM[dir];
          fdir = ORDINALS[(findex + rot_num) % 4];
          if (rot_num % 2 !== 0) {
            tx = pos.x;
            ty = pos.y;
            pos.x = ty;
            pos.y = tx;
          }
          switch (fdir) {
          case 'nw':
            if (tempPoint1.y < -2 * rad || tempPoint1.x < -2 * rad) {
              pos.x = Math.min(yDist / sr - pos.y / tr, xDist / cr + pos.y * tr);
            }
            break;
          case 'se':
            if (tempPoint1.y > height + 2 * rad || tempPoint1.x > width + 2 * rad) {
              pos.x = -Math.min(yDist / sr + pos.y / tr, xDist / cr - pos.y * tr);
            }
            break;
          case 'ne':
            if (tempPoint1.y < -2 * rad || tempPoint1.x > width + 2 * rad) {
              pos.y = Math.min(yDist / cr - pos.x * tr, xDist / sr + pos.x / tr);
            }
            break;
          case 'sw':
            if (tempPoint1.y > height + 2 * rad || tempPoint1.x < -2 * rad) {
              pos.y = -Math.min(yDist / cr + pos.x * tr, xDist / sr - pos.x / tr);
            }
          }
          if (rot_num % 2 !== 0) {
            tx = pos.x;
            ty = pos.y;
            pos.x = ty;
            pos.y = tx;
          }
          pos.x += vel.x;
          results$.push(pos.y += vel.y);
        }
      }
      return results$;
    },
    shiftFalling: function(spin){
      var rad, i$, ref$, obj, dir, pos, tx, ty, results$ = [];
      rad = this.rad;
      for (i$ in ref$ = this.falling) {
        obj = ref$[i$];
        dir = obj.direction;
        pos = obj.position;
        tx = pos.x;
        ty = pos.y;
        switch (dir) {
        case 'left':
          ty += 2 * rad * spin;
          results$.push(pos.y = Math.abs(ty) >= mindist / 2 ? -pos.y : ty);
          break;
        case 'right':
          ty -= 2 * rad * spin;
          results$.push(pos.y = Math.abs(ty) >= mindist / 2 ? -pos.y : ty);
          break;
        case 'up':
          tx -= 2 * rad * spin;
          results$.push(pos.x = Math.abs(tx) >= mindist / 2 ? -pos.x : tx);
          break;
        case 'down':
          tx += 2 * rad * spin;
          results$.push(pos.x = Math.abs(tx) >= mindist / 2 ? -pos.x : tx);
        }
      }
      return results$;
    }
  };
  document.onkeydown = function(e){
    e = e || window.event;
    switch (e.which || e.keyCode) {
    case 37:
    case 65:
      Tristal.shiftFalling(-1);
      break;
    case 39:
    case 68:
      Tristal.shiftFalling(1);
    }
    e.preventDefault;
  };
  Tristal.initBullseye();
  Tristal.initMass();
  fallId = 0;
  Tristal.falling[fallId++] = Tristal.newFalling();
  animate = function(timestamp){
    tristalbox.rotation = (tristalbox.rotation + 0.001) % (Math.PI / 4);
    Tristal.dropFalling();
    renderer.render(stage);
    return requestAnimationFrame(animate);
  };
  animate();
  setInterval(function(){
    Tristal.falling[fallId++] = Tristal.newFalling();
  }, 1000);
  document.body.appendChild(renderer.view);
}).call(this);
